# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZJc0jS9d-tWMleJ5WAJZYoYldDCaIyI7
"""

# ================================
# TennisPredictor Bot - Avanzato
# - H2H reali
# - superficie specifica
# - analisi ultimi 5 match reali
# - ML (RandomForest) con /retrain
# - utilizzo quote bookmaker
# - inline buttons (Details, Explain)
# Tested for python-telegram-bot v20+
# ================================



import os, math, re, joblib
from datetime import datetime
import pandas as pd
from statistics import mean
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, CallbackQueryHandler, filters
)
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score, accuracy_score

# ================================
# CONFIG
# ================================
TOKEN = "8548605202:AAEEKM18hqUZA8GBQy7RblPxi3kCAbGOOuw"   # <<-- sostituisci qui il token
DATA_DIR = "/mnt/data"
MATCHES_FILE = os.path.join(DATA_DIR, "matches.csv")
PLAYERS_FILE = os.path.join(DATA_DIR, "player_stats_filled.csv")
MODEL_PATH = os.path.join(DATA_DIR, "rf_under21_model.joblib")
LOG_PATH = os.path.join(DATA_DIR, "predictions_log.csv")

# ================================
# UTIL: carica file
# ================================
def load_matches():
    if not os.path.exists(MATCHES_FILE):
        return pd.DataFrame()
    df = pd.read_csv(MATCHES_FILE)
    # ensure date parsed
    if 'date' in df.columns:
        try:
            df['date'] = pd.to_datetime(df['date'], errors='coerce')
        except:
            df['date'] = pd.to_datetime(df['date'].astype(str), format='%Y-%m-%d', errors='coerce')
    # ensure total_games exists
    if 'total_games' not in df.columns:
        # try parse score column
        def parse_games(score):
            if pd.isna(score): return None
            sets = re.findall(r"(\d+)-(\d+)", str(score))
            total = sum(int(a)+int(b) for a,b in sets)
            return total
        df['total_games'] = df.get('result').apply(parse_games)
    # create under label if missing
    if 'under21_label' not in df.columns:
        df['under21_label'] = df['total_games'].apply(lambda x: 1 if (not pd.isna(x) and x<=21) else 0)
    return df

def load_players():
    if not os.path.exists(PLAYERS_FILE):
        return pd.DataFrame()
    p = pd.read_csv(PLAYERS_FILE)
    return p

matches_df = load_matches()
players_df = load_players()

# index players for quick lookup
players_index = {}
if not players_df.empty:
    players_index = {row['player']: row for _, row in players_df.iterrows()}

# ================================
# HEAD-TO-HEAD & FORMA
# ================================
def h2h_stats(p1, p2, surface=None):
    """Return dict: wins_p1, wins_p2, total, wins_p1_surface, wins_p2_surface"""
    df = matches_df
    if df.empty:
        return {'wins_p1':0,'wins_p2':0,'total':0,'wins_p1_surface':0,'wins_p2_surface':0}
    cond = ((df['player1']==p1) & (df['player2']==p2)) | ((df['player1']==p2) & (df['player2']==p1))
    sub = df[cond]
    wins_p1 = ((sub['winner']==p1).sum()) if 'winner' in sub.columns else 0
    wins_p2 = ((sub['winner']==p2).sum()) if 'winner' in sub.columns else 0
    total = len(sub)
    wins_p1_surf = wins_p2_surf = 0
    if surface:
        ss = sub[sub['surface'].astype(str).str.lower().str.contains(surface.lower(), na=False)]
        wins_p1_surf = (ss['winner']==p1).sum()
        wins_p2_surf = (ss['winner']==p2).sum()
    return {'wins_p1':int(wins_p1),'wins_p2':int(wins_p2),'total':int(total),'wins_p1_surface':int(wins_p1_surf),'wins_p2_surface':int(wins_p2_surf)}

def last_n_matches(player, n=5):
    df = matches_df
    if df.empty:
        return []
    # find matches where player is involved
    sub = df[(df['player1']==player) | (df['player2']==player)].sort_values('date', ascending=False)
    return sub.head(n)

def player_form_score(player, n=5):
    last = last_n_matches(player, n)
    if last.empty:
        return 0.5
    wins = (last['winner']==player).sum()
    return wins / len(last)

# ================================
# FEATURE CALCULATION - for ML and rule-based
# ================================
def compute_features(p1, p2, extra):
    """Return feature dict used by ML and for explanation"""
    features = {}
    # ranks
    r1 = None; r2 = None
    if p1 in players_index:
        r1 = players_index[p1].get('avg_rank') if 'avg_rank' in players_index[p1] else players_index[p1].get('rank')
    if p2 in players_index:
        r2 = players_index[p2].get('avg_rank') if 'avg_rank' in players_index[p2] else players_index[p2].get('rank')
    features['rank_diff'] = (float(r2) - float(r1)) if (r1 is not None and r2 is not None and not pd.isna(r1) and not pd.isna(r2)) else 0.0

    # under historical
    u1 = players_index[p1].get('under21_pct')/100.0 if p1 in players_index and 'under21_pct' in players_index[p1] and not pd.isna(players_index[p1].get('under21_pct')) else 0.45
    u2 = players_index[p2].get('under21_pct')/100.0 if p2 in players_index and 'under21_pct' in players_index[p2] and not pd.isna(players_index[p2].get('under21_pct')) else 0.45
    features['avg_under'] = (u1 + u2)/2.0

    # form last5
    features['form_p1'] = player_form_score(p1,5)
    features['form_p2'] = player_form_score(p2,5)

    # head to head
    surf = extra.get('surface') if extra else None
    h2h = h2h_stats(p1,p2, surface=surf)
    features['h2h_total'] = h2h['total']
    features['h2h_p1_wins'] = h2h['wins_p1']
    features['h2h_p2_wins'] = h2h['wins_p2']
    features['h2h_p1_wins_surf'] = h2h['wins_p1_surface']
    features['h2h_p2_wins_surf'] = h2h['wins_p2_surface']

    # bookmaker implied if present
    if extra and 'book_odds_under' in extra and extra['book_odds_under']:
        try:
            odds = float(extra['book_odds_under'])
            features['book_implied_under'] = 1.0/odds
        except:
            features['book_implied_under'] = 0.5
    else:
        features['book_implied_under'] = 0.5

    # handedness adjustment
    h1 = players_index[p1].get('hand') if p1 in players_index else None
    h2 = players_index[p2].get('hand') if p2 in players_index else None
    features['hand_adj'] = 0.0
    if h1 and h2:
        if str(h1).strip().upper().startswith('R') and str(h2).strip().upper().startswith('L'):
            features['hand_adj'] = -0.04
        elif str(h1).strip().upper().startswith('L') and str(h2).strip().upper().startswith('R'):
            features['hand_adj'] = 0.04

    # surface simple indicator
    features['surface'] = surf if surf else ""

    return features

# ================================
# MODEL: train / predict
# ================================
def train_model():
    df = matches_df.copy()
    df = df.dropna(subset=['total_games'])  # only matches with games
    df['under21_label'] = df['total_games'].apply(lambda x: 1 if x<=21 else 0)
    # create simple features
    rows=[]
    for _, row in df.iterrows():
        p1 = row['player1']; p2 = row['player2']
        extra = {'surface': row.get('surface'), 'book_odds_under': row.get('player1_odd')}
        feat = compute_features(p1,p2,extra)
        feat_row = {
            'rank_diff': feat['rank_diff'],
            'avg_under': feat['avg_under'],
            'form_diff': feat['form_p1'] - feat['form_p2'],
            'h2h_total': feat['h2h_total'],
            'h2h_diff': feat['h2h_p1_wins'] - feat['h2h_p2_wins'],
            'book_implied_under': feat['book_implied_under'],
            'hand_adj': feat['hand_adj'],
            'label': row['under21_label']
        }
        rows.append(feat_row)
    featdf = pd.DataFrame(rows).dropna()
    if featdf.empty:
        return None, "Dati insufficienti per il training."
    X = featdf.drop(columns=['label'])
    y = featdf['label']
    X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2, random_state=42)
    model = RandomForestClassifier(n_estimators=200, max_depth=8, random_state=42)
    model.fit(X_train, y_train)
    preds = model.predict(X_test)
    acc = accuracy_score(y_test, preds)
    f1 = f1_score(y_test, preds)
    joblib.dump(model, MODEL_PATH)
    return model, f"Trained RF: acc={acc:.3f}, f1={f1:.3f}, samples={len(X)}"

def load_model():
    if os.path.exists(MODEL_PATH):
        try:
            return joblib.load(MODEL_PATH)
        except:
            return None
    return None

# try load model at startup
rf_model = load_model()

# ================================
# PREDICT (combina ML se presente altrimenti rules)
# ================================
def rule_predict(p1,p2,extra):
    f = compute_features(p1,p2,extra)
    # baseline from avg_under and adjustments
    prob = 0.45 * f['avg_under'] + 0.2 * f['book_implied_under'] + 0.1 * (f['form_p1'] - f['form_p2']) + 0.05 * (f['h2h_p1_wins'] - f['h2h_p2_wins'])
    prob += f['hand_adj']
    # surface tweak
    if extra.get('surface'):
        s = extra.get('surface').lower()
        if 'clay' in s: prob += 0.03
        if 'grass' in s: prob += 0.02
        if 'hard' in s: prob -= 0.02
    prob = max(0.01, min(0.99, prob))
    return prob, f

def ml_predict(p1,p2,extra):
    global rf_model
    if rf_model is None:
        return None, None
    feat = compute_features(p1,p2,extra)
    row = {
        'rank_diff': feat['rank_diff'],
        'avg_under': feat['avg_under'],
        'form_diff': feat['form_p1'] - feat['form_p2'],
        'h2h_total': feat['h2h_total'],
        'h2h_diff': feat['h2h_p1_wins'] - feat['h2h_p2_wins'],
        'book_implied_under': feat['book_implied_under'],
        'hand_adj': feat['hand_adj'],
    }
    X = pd.DataFrame([row])
    prob = rf_model.predict_proba(X)[0][1]  # prob under
    return float(prob), feat

# ================================
# TELEGRAM Handlers and inline callbacks
# ================================
HELP_TEXT = (
    "ðŸŽ¾ TennisPredictor Help\n\n"
    "Formato rapido: PlayerA vs PlayerB\n"
    "Opzionale: PlayerA, PlayerB, surface, book_odds_under\n\n"
    "Comandi:\n"
    "/start /help /retrain /predict_latest\n"
    "Esempio: Sinner, Ruud, hard, 1.95"
)

async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ðŸŽ¾ Bot attivo! Usa /help per istruzioni.")

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(HELP_TEXT)

async def retrain_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = await update.message.reply_text("â³ Avvio re-train del modello...")
    model, info = train_model()
    global rf_model
    rf_model = model
    await update.message.reply_text("âœ… " + str(info))

async def predict_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    text = text.replace(" vs ", ",").replace(" VS ", ",").replace(" - ", ",")
    parts = [p.strip() for p in text.split(",") if p.strip()]
    if len(parts) < 2:
        await update.message.reply_text("Formato non riconosciuto. Usa: PlayerA vs PlayerB")
        return
    p1, p2 = parts[0], parts[1]
    extra = {}
    if len(parts) >= 3:
        extra['surface'] = parts[2]
    if len(parts) >= 4:
        try:
            extra['book_odds_under'] = float(parts[3])
        except: pass

    # ensure player names exist in players list (try simple matching)
    def find_name(name):
        # exact
        if name in players_index: return name
        # try lowercase contains
        for k in players_index.keys():
            if name.lower() in k.lower(): return k
        return None

    p1_key = find_name(p1); p2_key = find_name(p2)
    if not p1_key or not p2_key:
        await update.message.reply_text("Uno o entrambi i giocatori non presenti nel DB. Controlla ortografia.")
        return

    # ML predict if model available
    ml_prob, feat = ml_predict(p1_key,p2_key,extra)
    rule_prob, feat_rule = rule_predict(p1_key,p2_key,extra)

    # combine: prefer ML if available
    if ml_prob is not None:
        prob = 0.7 * ml_prob + 0.3 * rule_prob
        source = "ML+Rules"
    else:
        prob = rule_prob
        source = "Rules"

    pct = round(prob*100,1)
    suggestion = "UNDER 21.5" if prob>0.55 else ("OVER 21.5" if prob<0.45 else "NO STRONG EDGE")

    # store log
    log_row = {
        'timestamp': datetime.utcnow().isoformat(),
        'p1': p1_key, 'p2': p2_key, 'surface': extra.get('surface'), 'book_odds_under': extra.get('book_odds_under'),
        'prob_under': prob, 'suggestion': suggestion, 'source': source
    }
    try:
        lf = pd.DataFrame([log_row])
        if os.path.exists(LOG_PATH):
            lf.to_csv(LOG_PATH, mode='a', header=False, index=False)
        else:
            lf.to_csv(LOG_PATH, index=False)
    except Exception as e:
        print("Log error:", e)

    # prepare inline keyboard
    keyboard = [
        [InlineKeyboardButton("Dettagli", callback_data=f"DETAILS|{p1_key}|{p2_key}|{extra.get('surface','')}")],
        [InlineKeyboardButton("Spiegazione breve", callback_data=f"EXPLAIN|{p1_key}|{p2_key}|{extra.get('surface','')}")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        f"ðŸŽ¯ {p1_key} vs {p2_key}\nProbabilitÃ  UNDER 21.5: {pct}%\nSuggerimento: {suggestion}\nFonte: {source}",
        reply_markup=reply_markup
    )

async def callback_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data.split("|")
    typ = data[0]
    p1 = data[1]; p2 = data[2]; surf = data[3] if len(data)>3 else None
    extra = {'surface': surf} if surf else {}
    if typ == "DETAILS":
        # full feature breakdown
        feat = compute_features(p1,p2,extra)
        h2h = h2h_stats(p1,p2, surf)
        s = (
            f"Dettagli {p1} vs {p2}\n"
            f"- H2H totale: {h2h['total']} ( {h2h['wins_p1']} - {h2h['wins_p2']} )\n"
            f"- H2H su superficie: {h2h['wins_p1_surface']} - {h2h['wins_p2_surface']}\n"
            f"- Form (ultime 5): {round(feat['form_p1'],2)} vs {round(feat['form_p2'],2)}\n"
            f"- Avg under storici: {round(feat['avg_under'],2)}\n"
            f"- Rank diff: {round(feat['rank_diff'],2)}\n"
            f"- Book implied under: {round(feat['book_implied_under'],2)}\n"
            f"- Hand adj: {round(feat['hand_adj'],2)}"
        )
        await q.edit_message_text(s)
    elif typ == "EXPLAIN":
        # short natural-language explanation
        feat = compute_features(p1,p2,extra)
        reasons=[]
        if feat['hand_adj'] < 0:
            reasons.append("Destro vs Mancino â†’ svantaggio per il destro")
        if feat['form_p1'] > feat['form_p2'] + 0.3:
            reasons.append(f"{p1} Ã¨ in forma recente")
        if feat['h2h_total']>0:
            reasons.append(f"H2H: {feat['h2h_p1_wins']} - {feat['h2h_p2_wins']}")
        if feat['avg_under']>0.5:
            reasons.append("Storico Under elevato")
        if not reasons:
            reasons=["Dati limitati, uso regole generali."]
        await q.edit_message_text("â€¢ " + "\nâ€¢ ".join(reasons))

# ================================
# SETUP BOT
# ================================
app = ApplicationBuilder().token(TOKEN).build()
app.add_handler(CommandHandler("start", start_cmd))
app.add_handler(CommandHandler("help", help_cmd))
app.add_handler(CommandHandler("retrain", retrain_cmd))
app.add_handler(CommandHandler("predict_latest", lambda u,c: predict_handler(u,c)))  # reuse
app.add_handler(CallbackQueryHandler(callback_query_handler))
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, predict_handler))

print("Avvio bot...")
app.run_polling()
print("Bot avviato.")
